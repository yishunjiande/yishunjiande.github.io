<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Gradle自定义插件的三种方式</title>
    <url>/2021/06/03/Android-gradle-customPlugin/</url>
    <content><![CDATA[<p>gradle是一种构建工具，用来控制代码的编译、构建、打包等过程，自定义Gradle在Android中应用是很广泛的，比如在gradle构建过程中使用字节码技术、默认的Android项目中应用了很多插件，比如java、groovy、com.android.application等，了解Gradle插件有助于更好的理解生成APK的过程。</p>
<p>自定义插件三种方式：</p>
<ul>
<li>build script：在<code>build.gradle</code>脚本中直接编写，只能在本文件内使用；</li>
<li>buildSrc项目：新建一个名为<code>buildSrc</code>的Module，只能在本项目中使用；</li>
<li>独立的项目：在独立的项目中编写插件，发布到本地或者远程maven仓库供其他项目使用。</li>
</ul>
<span id="more"></span>
<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><p>本文基于Android进行讲解，实际上任何一个gradle project都可以，阅读本文你可以需要具备基本的gradle知识、groovy语法，可以参考我的两外两篇文章。<br><a href=""></a><br><a href=""></a><br>建议有gradle基础的和英文水平较高的直接阅读Gradle官方文档：<a href="https://docs.gradle.org/current/userguide/custom_plugins.html">Gradle custom_plugins</a></p>
<h2 id="2-方式一：build-script"><a href="#2-方式一：build-script" class="headerlink" title="2. 方式一：build script"></a>2. 方式一：build script</h2><p>直接在脚本文件中编写插件，线上项目一般不这样做。</p>
<h3 id="2-1-创建Project编辑project下的buid-gradle文件"><a href="#2-1-创建Project编辑project下的buid-gradle文件" class="headerlink" title="2.1 创建Project编辑project下的buid.gradle文件"></a>2.1 创建Project编辑project下的buid.gradle文件</h3><p>创建一个project，直接在app module下的build.gradle脚本文件编写插件。<br>示例：<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210603224249.png" alt="Build script1"><br>编辑build.gradle文件，新增插件GreetingPlugin，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">class GreetingPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    void apply(Project project) &#123;</span><br><span class="line">        println &quot;GreetingPlugin&quot;</span><br><span class="line">        project.task(&#x27;hello&#x27;) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println &#x27;Hello from the GreetingPlugin&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//应用插件</span><br><span class="line">apply plugin: GreetingPlugin</span><br></pre></td></tr></table></figure>
<p>不推荐这样做：</p>
<ul>
<li>维护成本高：造成build.gradle文件过于臃肿</li>
<li>无法复用：plugin只能在app module中使用，不能给其他module和project使用。</li>
</ul>
<h3 id="2-2-build-gradle优化的方式"><a href="#2-2-build-gradle优化的方式" class="headerlink" title="2.2 build.gradle优化的方式"></a>2.2 build.gradle优化的方式</h3><p>通过<code>apply from: &#39;../script/xxx.gradle&#39;</code>应用<code>xxx.gradle</code>脚本中编写的插件。<br>创建<code>script/test.gralde</code>文件并添加以上脚本内容。如图：<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210603224355.png" alt="Build script2"><br>在<code>app module</code>使用，添加<code>apply from: &#39;../script/test.gradle&#39;</code>即可应用<code>test.gralde</code>脚本。<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210603224511.png" alt="Build script3"></p>
<h2 id="3-方式二：buildSrc"><a href="#3-方式二：buildSrc" class="headerlink" title="3.方式二：buildSrc"></a>3.方式二：buildSrc</h2><p>一般用于本地调试使用</p>
<h3 id="3-1-搭建buildSrc-module"><a href="#3-1-搭建buildSrc-module" class="headerlink" title="3.1 搭建buildSrc module"></a>3.1 搭建buildSrc module</h3><p>在工程中新建buildSrc目录，<strong>名称一定不能写错</strong>，在buildSrc目录下建立如下目录和文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  main/</span><br><span class="line">    groovy/</span><br><span class="line">build.gradle</span><br></pre></td></tr></table></figure>
<p>编辑build.gradle文件，添加如下内容:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &#x27;groovy&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    implementation localGroovy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>项目结构如下：<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210603224914.png" alt="buildSrc1"><br>点击<code>sync</code>或者<code>buid project</code><strong>（这一步必须）</strong>，会生成build目录，groovy目录也会变成源文件目录，之后就可以创建包和源代码。</p>
<h3 id="3-2-写插件"><a href="#3-2-写插件" class="headerlink" title="3.2 写插件"></a>3.2 写插件</h3><p>在groovy目录下新建包（new-&gt;package）：com.learn.plugin。<br>新建MyPlugin.groovy文件，必须以.groovy为后缀。添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.learn.plugin</span><br><span class="line">import org.gradle.api.Plugin</span><br><span class="line">import org.gradle.api.Project</span><br><span class="line"></span><br><span class="line">class MyPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) &#123;</span><br><span class="line">        println(&quot;Hello gradle plugin&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里插件已经写好了，在其他地方使用即可。</p>
<h3 id="3-3-其他module中使用buildSrc中的插件"><a href="#3-3-其他module中使用buildSrc中的插件" class="headerlink" title="3.3 其他module中使用buildSrc中的插件"></a>3.3 其他module中使用buildSrc中的插件</h3><p>在app module下的build.gradle中应用插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apply plugin: com.learn.plugin.MyPlugin</span><br></pre></td></tr></table></figure>
<p>在终端输入如下命令验证:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./gradlew assemble</span><br></pre></td></tr></table></figure>

<p>或者直接Run也可以。<br>输出如下内容表示成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Configure project :app</span><br><span class="line">Hello gradle plugin</span><br></pre></td></tr></table></figure>
<h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><ul>
<li>module名称必须是buildSrc</li>
<li>一般本地调试使用，项目中使用都是远程jar包形式，即第三种方式</li>
</ul>
<h2 id="4-方式三：独立项目"><a href="#4-方式三：独立项目" class="headerlink" title="4.方式三：独立项目"></a>4.方式三：独立项目</h2><p>这种方式是项目中常用的，最后生成的是jar包，可以发布在本地或者远程仓库（jcenter、maven），方便其他项目使用。</p>
<h3 id="4-1-新建写插件的module"><a href="#4-1-新建写插件的module" class="headerlink" title="4.1 新建写插件的module"></a>4.1 新建写插件的module</h3><p>新建一个module（新建一个工程也可以，因为最后生成和使用都是jar包的形式），module名称随意，只保留build.gradle文件和src/main目录，其余文件全部删掉。<br>修改build.gradle文件内容，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;groovy&#x27; //必须，groovy写插件必须</span><br><span class="line">apply plugin: &#x27;maven&#x27;  //要想发布到Maven，此插件必须使用</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi() //必须</span><br><span class="line">    implementation localGroovy() //必须</span><br><span class="line">&#125;</span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral() //必须</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def group=&#x27;com.hh.cus_plugin&#x27; //组</span><br><span class="line">def artifactId=&#x27;myGradlePlugin&#x27; //唯一标示</span><br><span class="line">def version=&#x27;1.0.0&#x27; //版本</span><br><span class="line"></span><br><span class="line">def uploadRepo = new File(System.getProperty(&quot;user.home&quot;) + &quot;/.hhrepo&quot;)</span><br><span class="line">//将插件打包上传到本地maven仓库</span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            pom.groupId = group</span><br><span class="line">            pom.artifactId = artifactId</span><br><span class="line">            pom.version = version</span><br><span class="line">            //指定本地maven的路径，在项目根目录下</span><br><span class="line">            repository(url: uri(uploadRepo))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比buildSrc方案，增加了Maven的支持和uploadArchives这样一个Task，这个Task的作用是为了将插件打包上传到本地maven仓库。<br>这里使用的本地地址：<code>/Users/username(你电脑的名称)/.hhrepo</code></p>
<h3 id="4-2-写插件"><a href="#4-2-写插件" class="headerlink" title="4.2 写插件"></a>4.2 写插件</h3><p>同方式二，这里直接给出结果：<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210603225158.png" alt="AGP3"></p>
<h3 id="4-3-发布"><a href="#4-3-发布" class="headerlink" title="4.3 发布"></a>4.3 发布</h3><p>在终端中执行<code>./gradlew uploadArchives</code>指令，或者展开Android Studio右侧的Gradle，找到对应<code>module-&gt;uploadArchivesTask</code>，就可以将插件部署到相应的目录下。<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210603225411.png" alt="AGP3-2,-w337"><br>验证结果：<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210603225524.png" alt="-w495"></p>
<h3 id="4-4-其他项目使用"><a href="#4-4-其他项目使用" class="headerlink" title="4.4 其他项目使用"></a>4.4 其他项目使用</h3><p>修改project（根目录）下的build.gradle文件内容，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version = &quot;1.4.32&quot;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url uri(System.getProperty(&quot;user.home&quot;) + &quot;/.hhrepo&quot;) //指定本地maven的路径</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;com.android.tools.build:gradle:4.1.0&quot;</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line">        classpath &quot;com.hh.cus_plugin:myGradlePlugin:1.0.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在app中使用，修改app下的build.gradle，添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apply plugin: com.ccc.plugin.PluginTest//插件类的全限定名</span><br></pre></td></tr></table></figure>
<p>在终端输入如下命令验证:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./gradlew assemble</span><br></pre></td></tr></table></figure>
<p>或者直接Run也可以，看到相关提示则成功。</p>
<h3 id="4-5-总结"><a href="#4-5-总结" class="headerlink" title="4.5 总结"></a>4.5 总结</h3><ul>
<li>项目中一般使用这种方式，方便项目插件化</li>
</ul>
<h2 id="5-拓展"><a href="#5-拓展" class="headerlink" title="5. 拓展"></a>5. 拓展</h2><p>有人可能见过通过META-INF中properties配置插件，没错，这种配置是比较推荐的，对于提供独立自定义插件的JAR，强烈推荐这种做。<br>一般插件很少直接使用插件类的全限定名调用，比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//不推荐</span><br><span class="line">apply plugin:com.ccc.plugin.PluginTest</span><br></pre></td></tr></table></figure>
<p>基本上都是通过插件名或者叫插件id调用，比如官方的java、groovy、com.android.application等，都是通过如下配置使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//推荐</span><br><span class="line">apply plugin:&#x27;插件名&#x27;</span><br><span class="line">apply plugin:&#x27;groovy&#x27;</span><br><span class="line">apply plugin:&#x27;com.android.application&#x27;</span><br><span class="line">或者</span><br><span class="line">plugins&#123;</span><br><span class="line">    id &#x27;插件名&#x27;</span><br><span class="line">    id &#x27;java&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的原因：可能是不想插件类暴露出来吧，可以自定义别名。（以后知道原因了再更新）</p>
<p><strong>配置别名步骤：</strong><br>在main目录下新建<code>resources/META-INF/gradle-plugins</code>目录，名称不能随意填写。<br>在<code>gradle-plugins</code>下新建<code>name(插件名).properties</code>文件，这个name就是后面要使用的，如图：<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210603232446.png"><br>其他module使用这个插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apply plugin:&#x27;hhhhh&#x27;</span><br><span class="line">或者</span><br><span class="line">plugins&#123;</span><br><span class="line">    id &#x27;hhhhh&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>./gradlew assemble</code>验证</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>开发gradle插件掌握方式三就行了，关键是项目里面有相关的内容能看懂就行了，比如字节码插桩、编译优化等都会涉及AGP的内容。再此安利：<a href="https://docs.gradle.org/current/userguide/userguide.html">Gradle userguide</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>Android</tag>
        <tag>groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Gradle（一）Gradle的Android插件入门</title>
    <url>/2021/06/20/Android-gradle-start-1/</url>
    <content><![CDATA[<p>新建一个Android项目，默认使用Gradle进行构建，相信大家或多或少都听过Gradle，Gralde也是现在项目构建的主流工具。看到项目中杂乱gradle配置，你是否手足无措，莫慌，本文将带你了解Android中Gradle插件。</p>
<span id="more"></span>
<h2 id="1-什么是Gradle的Android插件"><a href="#1-什么是Gradle的Android插件" class="headerlink" title="1.什么是Gradle的Android插件"></a>1.什么是Gradle的Android插件</h2><p>Gradle有很多插件，为了支持Android项目的构建，谷歌为Gradle编写了Android插件，新的Android构建系统就是由Gradle的Android插件组成的，Gradle是一个高级构建工具包，它管理依赖项并允许开发者自定义构建逻辑。Android Studio使用Gradle wrapper来集成Gradle的Android插件。需要注意的是，Gradle的Android插件也可以独立于AndroidStudio运行。</p>
<p>在 Android的官方网站提到了新的Android构建系统主要有以下几个特点：</p>
<ul>
<li>代码和资源易于重用</li>
<li>无论是针对多个apk发行版还是针对不同风格的应用程序，都可以很容易创建应用程序的多个不同版本。</li>
<li>易于配置、扩展和自定义构建过程</li>
<li>良好的IDE集成</li>
</ul>
<p>Gradle的Android插件结合Android Studio成为了目前最为流行的Android构建系统。</p>
<h2 id="2-Android-Studio的模块类型"><a href="#2-Android-Studio的模块类型" class="headerlink" title="2.Android Studio的模块类型"></a>2.Android Studio的模块类型</h2><p>Android Studio中的每个项目包含一个或多个含有源代码文件和资源文件的模块，这些模块可以独立构建、测试或调试，一个Android Studio的模块类型可以有以下几种：</p>
<h3 id="2-1-Android应用程序模块"><a href="#2-1-Android应用程序模块" class="headerlink" title="2.1 Android应用程序模块"></a>2.1 Android应用程序模块</h3><p>Android应用程序模块可能依赖于库模块，尽管许多Android应用程序只包含一个应用程序模块，构建系统会将其生成一个APK。<br>模块的build.gradle包含：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;com.android.application&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Android-库模块"><a href="#2-2-Android-库模块" class="headerlink" title="2.2 Android 库模块"></a>2.2 Android 库模块</h3><p>Android库模块包含可重用的特定于Android的代码和资源，构建系统会将其生成一个AAR。<br>模块的build.gradle包含：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;com.android.library&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Java库模块"><a href="#2-3-Java库模块" class="headerlink" title="2.3 Java库模块"></a>2.3 Java库模块</h3><p>包含可重用的代码，构建系统会将其生成一个JAR包。<br>模块的build.gradle包含：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;com.android.library&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="3-一个Android项目视图"><a href="#3-一个Android项目视图" class="headerlink" title="3. 一个Android项目视图"></a>3. 一个Android项目视图</h2><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210620231811.png" width="50%" height="50%">
所有构建文件在Gradle Scripts层级下显示，大概介绍下这些文件的用处。

<ul>
<li>项目build.gradle：配置项目的整体属性，比如指定使用的代码仓库、依赖的Gradle插件版本等等。</li>
<li>模块build.gradle：配置当前Module的编译参数。</li>
<li>gradle-wrapper.properites：配置Gradle Wrapper。</li>
<li>gradle.properties：配置Gradle的编译参数。具体配置见<a href="https://docs.gradle.org/current/userguide/build_environment.html">Gradle官方文档</a></li>
<li>settings.gradle：配置Gradle的多项目管理。</li>
<li>local.properties：一般用来存放该Android项目的私有属性配置，比如Android项目的SDK路径。</li>
</ul>
<p>接下来将简单介绍它们，先讲简单的，重点讲项目build.gradle和模块build.gradle。</p>
<h3 id="3-1-local-properties"><a href="#3-1-local-properties" class="headerlink" title="3.1 local.properties"></a>3.1 local.properties</h3><p>通常用于SDK路径、NDK路径等Android项目的私有属性配置，比如：<code>local.properties</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ndk.dir=/Users/username/Downloads/android-ndk-r19c</span><br><span class="line">sdk.dir=/Users/username/Downloads/sdk</span><br></pre></td></tr></table></figure>
<h3 id="3-2-settings-gradle"><a href="#3-2-settings-gradle" class="headerlink" title="3.2 settings.gradle"></a>3.2 settings.gradle</h3><p>配置Gradle的多项目管理，一个项目中所有的module都include在这里。比如：<code>settings.gradle</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">include &#x27;:LibJavaLibrary&#x27;</span><br><span class="line">include &#x27;:LibAndroidLibrary&#x27;</span><br><span class="line">include &#x27;:app&#x27;</span><br><span class="line">rootProject.name = &quot;GradleTestDemo&quot;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-gradle-properties"><a href="#3-3-gradle-properties" class="headerlink" title="3.3 gradle.properties"></a>3.3 gradle.properties</h3><p>配置Gradle的编译参数。具体配置见<a href="https://docs.gradle.org/current/userguide/build_environment.html">Gradle官方文档</a><br>比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Specifies the JVM arguments used <span class="keyword">for</span> the daemon process.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置gradle守护进程的JVM参数，内存和编码格式</span></span><br><span class="line">org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8</span><br><span class="line"><span class="meta">#</span><span class="bash"> AndroidX package structure to make it clearer <span class="built_in">which</span> packages are bundled with the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Android operating system, and <span class="built_in">which</span> are packaged with your app<span class="string">&quot;s APK</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> https://developer.android.com/topic/libraries/support-library/androidx-rn</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 是否使用AndroidX</span></span></span><br><span class="line">android.useAndroidX=true</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Automatically convert third-party</span></span> </span><br><span class="line">libraries to use AndroidX</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 三方库是否使用AndroidX</span></span></span><br><span class="line">android.enableJetifier=true</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Kotlin code style for this project: &quot;</span>official<span class="string">&quot; or &quot;</span>obsolete<span class="string">&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 设置kotlin代码样式为“official”</span></span></span><br><span class="line">kotlin.code.style=official</span><br></pre></td></tr></table></figure>
<h3 id="3-4-gradle-properties"><a href="#3-4-gradle-properties" class="headerlink" title="3.4 gradle.properties"></a>3.4 gradle.properties</h3><p>配置Gradle Wrapper，主要是为了标准化项目。只要项目配置了gradle wrapper，就可以指定gradle版本等信息。关于Gradle Wrapper可以看这篇文章：<br><a href="http://liuwangshu.cn/application/gradle/4-wrapper.html">Gradle核心思想（四）看似无用，实则重要的Gradle Wrapper</a><br>比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Sat Jun 19 21:24:56 CST 2021</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Gradle解包后存储的主目录</span></span><br><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line"><span class="meta">#</span><span class="bash"> distributionBase指定目录的子目录。distributionBase+distributionPath就是Gradle解包后的存放位置</span></span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line"><span class="meta">#</span><span class="bash"> Gradle压缩包存储主目录</span></span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line"><span class="meta">#</span><span class="bash"> zipStoreBase指定目录的子目录。zipStoreBase+zipStorePath就是Gradle压缩包的存放位置。</span></span><br><span class="line">zipStorePath=wrapper/dists</span><br><span class="line"><span class="meta">#</span><span class="bash"> gradle下载的url地址，如果不能翻墙可以使用国内镜像，或者将gradle放在自己的服务器上</span></span><br><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-6.5-bin.zip</span><br></pre></td></tr></table></figure>

<h3 id="3-5-项目build-gradle"><a href="#3-5-项目build-gradle" class="headerlink" title="3.5 项目build.gradle"></a>3.5 项目build.gradle</h3><p>项目build.gradle指的是根目录下的build.gradle文件。它的作用主要有以下几点：</p>
<ul>
<li><p>统一管理项目的版本号，比如库的版本号、SDK版本号等</p>
</li>
<li><p>配置classpath的仓库地址，classpth一般是build.gradle脚本需要使用的资源，比如Gradle插件，必须添加如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classpath &quot;com.android.tools.build:gradle:4.1.3&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>配置module中依赖的仓库地址，通过allprojects的repositories {}配置</p>
</li>
</ul>
<p>一个新建的Android项目，项目build.gradle内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span><br><span class="line">// 顶级构建文件，您可以在其中添加所有子项目/模块通用的配置选项。</span><br><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version = &quot;1.3.72&quot;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;com.android.tools.build:gradle:4.1.3&quot;</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line"></span><br><span class="line">        // NOTE: Do not place your application dependencies here; they belong</span><br><span class="line">        // in the individual module build.gradle files</span><br><span class="line">        //注意：不要将您的应用程序依赖项放在这里；它们属于单个模块 build.gradle 文件</span><br><span class="line">        // 意思就是应用程序的dependencies应该在对应module下的build.gradle中配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//各module中依赖的仓库</span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clean(type: Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常项目build.gradle文件还有如下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//统一管理库版本号、SDK版本号等，在module中的build.gradle中可以通过rootProject.compileSdkVersion使用</span><br><span class="line">ext &#123;</span><br><span class="line">    compileSdkVersion = 29</span><br><span class="line">    buildToolsVersion = &quot;28.0.3&quot;</span><br><span class="line">    minSdkVersion = 18</span><br><span class="line">    targetSdkVersion = 28</span><br><span class="line"></span><br><span class="line">    AppVersionCode = 595000</span><br><span class="line">    AppVersionName = &quot;5.95.0&quot;</span><br><span class="line">    LogicVersionCode = 595000</span><br><span class="line">    LogicVersionName = &quot;5.95.0&quot;</span><br><span class="line"></span><br><span class="line">    frescoVersion = &quot;1.9.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-模块build-gradle"><a href="#3-6-模块build-gradle" class="headerlink" title="3.6 模块build.gradle"></a>3.6 模块build.gradle</h3><p>一个新Android项目的app模块的build.gradle内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    //应用程序插件，表示当前module是应用程序模块，编译生成APK</span><br><span class="line">    id &#x27;com.android.application&#x27;</span><br><span class="line">    //kotlin插件</span><br><span class="line">    id &#x27;kotlin-android&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用于描述该Module构建过程中所用到的所有参数</span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion rootProject.compileSdkVersion</span><br><span class="line">    buildToolsVersion rootProject.buildToolsVersion</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId &quot;com.hh.gradletestdemo&quot;</span><br><span class="line">        minSdkVersion 17</span><br><span class="line">        targetSdkVersion 30</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&#x27;proguard-android-optimize.txt&#x27;), &#x27;proguard-rules.pro&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        jvmTarget = &#x27;1.8&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line">    implementation &quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;</span><br><span class="line">    implementation &#x27;androidx.core:core-ktx:1.5.0&#x27;</span><br><span class="line">    implementation &#x27;androidx.appcompat:appcompat:1.3.0&#x27;</span><br><span class="line">    implementation &#x27;com.google.android.material:material:1.3.0&#x27;</span><br><span class="line">    implementation &#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;</span><br><span class="line">    testImplementation &#x27;junit:junit:4.+&#x27;</span><br><span class="line">    androidTestImplementation &#x27;androidx.test.ext:junit:1.1.2&#x27;</span><br><span class="line">    androidTestImplementation &#x27;androidx.test.espresso:espresso-core:3.3.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模块中比较重要的几项配置：<br><strong>1.Gradle的Android插件类型</strong><br>apply引入的插件id为com.android.application，说明当前模块是一个应用程序模块，Gradle的Android插件有多个类型分别为：</p>
<ul>
<li>应用程序插件，插件id为<code>com.android.application</code>，会生成一个APK。</li>
<li>库插件，插件id为<code>com.android.library</code>，会生成一个AAR，提供给其他应用程序模块用。</li>
<li>java插件，插件id为<code>java-library</code>，会生成Jar包，提供给其他应用程序模块用。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>Android</tag>
        <tag>groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>详解Java字节码文件</title>
    <url>/2020/05/31/JVM-bytecode-analysis/</url>
    <content><![CDATA[<p>引用两句话来说明字节码文件的重要性：</p>
<blockquote>
<p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。来自《深入理解Java虚拟机》-周志明  </p>
</blockquote>
<blockquote>
<p>理解字节码以及理解Java编译器如何生成Java字节码与学习汇编知识对于C/C++程序员有一样的意义。来自IBM developerWorks周刊</p>
</blockquote>
<p>本人在学习字节码文件后，明显能感觉到的几个好处：</p>
<ul>
<li>可以更好的理解Java语言特性</li>
<li>对以后学习Javassist、ASM等字节码操作工具有很大帮助</li>
<li>解三方库源码问题，能更好的定位、解决问题</li>
</ul>
<p>阅读本文，你将学会如何分析字节码内容。</p>
<span id="more"></span>
<h2 id="1-基础认识"><a href="#1-基础认识" class="headerlink" title="1. 基础认识"></a>1. 基础认识</h2><p>字节码技术是Java虚拟机实现<strong>平台无关性</strong>和<strong>语言无关性</strong>的关键。这句话有两层含义：</p>
<ul>
<li>java语言，“一处编译，处处运行”，说的就是Java虚拟机的平台无关性，Java虚拟机实现了不同平台的兼容，Java虚拟机只需加载符合《Java虚拟机规范》的字节码即可。</li>
<li>因为虚拟机只与字节码“打交道”，所以源码存在的形式不一定是Java语言，因此诞生了Groovy语言、JRuby语言等，它们通过编译器生成字节码，供Java虚拟机使用。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210531233725.png" alt="语言无关性"></p>
<h2 id="2-字节码文件结构"><a href="#2-字节码文件结构" class="headerlink" title="2 字节码文件结构"></a>2 字节码文件结构</h2><p>首先我们来统一术语，通常说的“字节码文件”、“.class文件”、“class文件”都是指的字节码文件，本文将统一使用字节码文件描述。</p>
<p>注意：字节码的载体不一定非得是磁盘文件，也可以是来源于网络</p>
]]></content>
      <categories>
        <category>Java虚拟机</category>
        <category>字节码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
        <tag>字节码</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上使用Hexo+github搭建个人博客</title>
    <url>/2018/12/16/hello_my_blog/</url>
    <content><![CDATA[<p>通过google查问题的时候，看到一些博客风格很简约，博客内容质量很好，不由觉得想要拥有，得知这样的博客都是通过hexo+github搭建的，都是开源免费的，那必须得自己搞一个了，话不多说，开搞！</p>
<span id="more"></span>

<h2 id="1-基础认识"><a href="#1-基础认识" class="headerlink" title="1. 基础认识"></a>1. 基础认识</h2><h3 id="1-1-先来一张预览图尝鲜"><a href="#1-1-先来一张预览图尝鲜" class="headerlink" title="1.1 先来一张预览图尝鲜"></a>1.1 先来一张预览图尝鲜</h3><p><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210529215609.png" alt="blog预览图"><br>或者访问<code>https://kt-learn.cn/</code>网址查看，我知道你懒，给个传送门：<a href="https://kt-learn.cn/">go</a></p>
<h3 id="1-2-Hexo相关介绍"><a href="#1-2-Hexo相关介绍" class="headerlink" title="1.2 Hexo相关介绍"></a>1.2 Hexo相关介绍</h3><blockquote>
<p>来源于Hexo官方  </p>
</blockquote>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h3 id="1-3-系统环境"><a href="#1-3-系统环境" class="headerlink" title="1.3 系统环境"></a>1.3 系统环境</h3><p>MacOs BigSur 11.3.1</p>
<h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a>2. 安装Hexo</h2><p>希望你已经安装了HomeBrew，相信用Mac电脑的人都有吧，没有请安装一个，参考：<a href="https://www.cnblogs.com/haojile/p/13193805.html">Mac安装Homebrew</a></p>
<h3 id="2-1-安装git"><a href="#2-1-安装git" class="headerlink" title="2.1 安装git"></a>2.1 安装git</h3><p>如果已经安装请忽略这步。<br>安装git命令（brew命令可用必须是已经安装了HomeBrew）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure>
<p>或者参考：<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git">1.5 起步 - 安装 Git</a><br>验证git是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ git --version</span><br><span class="line">git version 2.30.1 (Apple Git-130)</span><br></pre></td></tr></table></figure>
<h3 id="2-2-安装node"><a href="#2-2-安装node" class="headerlink" title="2.2 安装node"></a>2.2 安装node</h3><p>如果已经安装请忽略这步。<br>安装node命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>
<p>验证node安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ node -v</span><br><span class="line">v16.2.0</span><br><span class="line">➜ npm -v</span><br><span class="line">7.13.0</span><br></pre></td></tr></table></figure>
<h3 id="2-3-安装hexo"><a href="#2-3-安装hexo" class="headerlink" title="2.3 安装hexo"></a>2.3 安装hexo</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>验证hexo安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ hexo -v</span><br><span class="line">INFO  Validating config</span><br><span class="line">hexo: 5.4.0</span><br><span class="line">hexo-cli: 4.2.0</span><br></pre></td></tr></table></figure>
<h3 id="2-4-开始搭建博客"><a href="#2-4-开始搭建博客" class="headerlink" title="2.4 开始搭建博客"></a>2.4 开始搭建博客</h3><p>至1.3就已经安装好Hexo了，现在开始开始自己的博客搭建。<br>创建本地博客目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ mkdir blog</span><br><span class="line">➜ cd blog</span><br></pre></td></tr></table></figure>
<p>执行hexo init(当前是blog目录):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ hexo init</span><br></pre></td></tr></table></figure>
<p>生成静态网页并本地部署：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ hexo g//这是hexo generate的简写，本文全部使用简写</span><br><span class="line">➜ hexo s</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>浏览器打开<code>http://localhost:4000</code>查看，出现如下结果：<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210529223342.png" alt="init image"><br>到这里已经搭建好了博客，并且本地是可以访问了，这样还不够酷，将它放到网上，那样任何人都可以查看，cool。</p>
<h2 id="3-将博客部署到Github-Pages上"><a href="#3-将博客部署到Github-Pages上" class="headerlink" title="3. 将博客部署到Github Pages上"></a>3. 将博客部署到Github Pages上</h2><h3 id="3-1-注册-Github-账户"><a href="#3-1-注册-Github-账户" class="headerlink" title="3.1 注册 Github 账户"></a>3.1 注册 Github 账户</h3><p>如果有请忽略。<br><a href="https://github.com/">点击此处</a>访问 Github 官网，点击 Sign Up 注册账户</p>
<h3 id="3-2-创建项目代码库"><a href="#3-2-创建项目代码库" class="headerlink" title="3.2 创建项目代码库"></a>3.2 创建项目代码库</h3><p>点击 New repository 开始创建，步骤及注意事项见图：<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210529232141.png" alt="创建repo"></p>
<h3 id="3-3-配置SSH"><a href="#3-3-配置SSH" class="headerlink" title="3.3 配置SSH"></a>3.3 配置SSH</h3><p>如果使用过github等托管服务的话，一般SSH已经配置好了，如果没有请参考：<a href="https://docs.github.com/cn/github/authenticating-to-github/connecting-to-github-with-ssh">使用 SSH 连接到 GitHub</a><br>测试SSH是否配置好：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ ssh -T git@github.com </span><br><span class="line">Hi yishunjiande! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<h3 id="3-4-将本地博客与youname-github-io关联"><a href="#3-4-将本地博客与youname-github-io关联" class="headerlink" title="3.4 将本地博客与youname.github.io关联"></a>3.4 将本地博客与youname.github.io关联</h3><p>登录 Github 打开自己的项目 yourname.github.io，复制SSH链接<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210529233600.png" alt="ssh url"><br>打开Hexo站点配置文件<code>_config.yml</code><br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210529233021.png" alt="hexo 目录结构"><br>文件末尾添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Deployment</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> :号后面空格是必须的，注意下分支是master还是main</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Docs: https://hexo.io/docs/one-command-deployment</span></span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:yishunjiande/yishunjiande.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<h3 id="3-5-将本地博客内容部署到github-pages上"><a href="#3-5-将本地博客内容部署到github-pages上" class="headerlink" title="3.5 将本地博客内容部署到github pages上"></a>3.5 将本地博客内容部署到github pages上</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ hexo g -d</span><br></pre></td></tr></table></figure>
<p>如果出现<code>ERROR Deployer not found: git</code>错误的话，则需安装<code>hexo-deployer-git</code>，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>再次执行<code>hexo g -d</code>命令，如果没有错误，则部署成功，可以去youname.github.io上看一下是不是多了很多文件。<br>在浏览器上输入<code>https://youname.github.io</code>访问你的博客，如果看到内容则成功。</p>
<h3 id="3-6-Hexo常用命令"><a href="#3-6-Hexo常用命令" class="headerlink" title="3.6 Hexo常用命令"></a>3.6 Hexo常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//清除缓存</span><br><span class="line">hexo clean </span><br><span class="line">//生成静态网页</span><br><span class="line">hexo g </span><br><span class="line">//本地启动预览查看</span><br><span class="line">hexo s </span><br><span class="line">//本地调试</span><br><span class="line">hexo s --debug</span><br><span class="line">部署到git服务器上：</span><br><span class="line">hexo deploy </span><br><span class="line"></span><br><span class="line">一般修改文章或者配置后先使用hexo s --debug本地看看效果</span><br><span class="line">没问题后直接使用hexo g -d部署到github上</span><br><span class="line"></span><br><span class="line">站点配置文件地址：</span><br><span class="line">~/blog/_config.yml</span><br><span class="line">主题配置文件地址</span><br><span class="line">~/blog/themes/next/_config.yml</span><br></pre></td></tr></table></figure>
<h2 id="4-更换主题"><a href="#4-更换主题" class="headerlink" title="4. 更换主题"></a>4. 更换主题</h2><p>博客搭建好了，那肯定要好好给它美化一下，毕竟Coder都是“颜控”。<br>Hexo支持很多主题，至于你喜欢哪种，可以去<a href="https://hexo.io/themes/">Hexo Theme官方</a>上找你喜欢的，将喜欢的主题clone下来配置就可生效，作者使用的NexT.Pisces，就是你看到的预览图的样式。</p>
<h3 id="4-1-NexT主题搭建"><a href="#4-1-NexT主题搭建" class="headerlink" title="4.1 NexT主题搭建"></a>4.1 NexT主题搭建</h3><p>关于NexT主题搭建，官方有详细的文档：<a href="https://theme-next.iissnan.com/">NexT</a><br>相信聪明的你对着官方文档操作一定能成功。<br>issue：NexT主题部署后乱码<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210527003120.png" alt="issue"><br>原因是hexo在5.0之后把swig给删除了需要自己手动安装<br>解决：安装swig<br>输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ npm i hexo-renderer-swig</span><br></pre></td></tr></table></figure>
<h3 id="4-2-主题优化"><a href="#4-2-主题优化" class="headerlink" title="4.2 主题优化"></a>4.2 主题优化</h3><p>NexT默认的配置已经能满足大部分了，如果需要优化的话，可以参考<a href="https://theme-next.iissnan.com/theme-settings.html">NexT的主题设置</a>，优化自己想要的部分。<br>如果官方文档不能满足你，你还可以参考以下链接：<br><a href="https://chenjiabing666.github.io/2020/10/26/%E5%A5%B3%E6%9C%8B%E5%8F%8B%E7%9C%8B%E4%BA%86%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%AF%B4%E5%A4%AALOW%E4%BA%86%EF%BC%8C%E4%BA%8E%E6%98%AF%E6%88%91%E6%8A%98%E8%85%BE%E4%BA%86%E4%B8%80%E5%A4%A9/">Hexo的Next主题优化教程</a><br><a href="https://lishibo-ios.github.io/2018/03/02/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89--%20%E4%BD%BF%E7%94%A8next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF/">博客搭建（二）– 使用next主题配置博客基本信息</a><br><a href="https://www.jianshu.com/p/f054333ac9e6">hexo的next主题个性化教程:打造炫酷网站</a><br>本人也不是做前端的，没办法写个性化的网站优化，都是google搜出来的，做个爱折腾的孩子吧，给爱折腾的孩子打call<br>本人比较喜欢简约风格，基本上没有改动，只对博客做了如下优化：</p>
<ul>
<li>增加评论系统</li>
<li>转载协议</li>
<li>添加分类、标签、关于页面</li>
<li>添加打赏按钮</li>
<li>…</li>
</ul>
<h2 id="5-给博客绑定自己的域名"><a href="#5-给博客绑定自己的域名" class="headerlink" title="5. 给博客绑定自己的域名"></a>5. 给博客绑定自己的域名</h2><p>本人本来就有一个域名闲置，所以就顺手使用了，如果没有域名的同学完全可以使用github的网址访问博客。<br>博客绑定域名教程参考：<br><a href="http://duansm.top/2018/08/07/hexo-dns/">Hexo+github搭建个人博客（四）：博客域名解析</a></p>
<h2 id="6-配置百度和谷歌收录博客"><a href="#6-配置百度和谷歌收录博客" class="headerlink" title="6. 配置百度和谷歌收录博客"></a>6. 配置百度和谷歌收录博客</h2><p>参考：<a href="http://duansm.top/2018/08/08/hexo-sitemap/">百度和谷歌收录博客</a></p>
<h2 id="7-写文章"><a href="#7-写文章" class="headerlink" title="7. 写文章"></a>7. 写文章</h2><h3 id="7-1-新建文章"><a href="#7-1-新建文章" class="headerlink" title="7.1 新建文章"></a>7.1 新建文章</h3><p>在blog根目录下，输入如下命令创建新的文章，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ hexo new &quot;pageName&quot;</span><br></pre></td></tr></table></figure>
<p>文章名最好是英文，因为文章的死链接路径中有它，带中文的话链接会变得很长。<br>执行完上述指令后，会在<code>source/_posts</code>目录下，生成<code>pageName.md文件</code>，编辑文件内容即可写文章</p>
<h3 id="7-2-文章相关格式"><a href="#7-2-文章相关格式" class="headerlink" title="7.2 文章相关格式"></a>7.2 文章相关格式</h3><h4 id="7-2-1-文章属性相关："><a href="#7-2-1-文章属性相关：" class="headerlink" title="7.2.1 文章属性相关："></a>7.2.1 文章属性相关：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 个人博客搭建（Mac+Hexo+github）</span><br><span class="line">tags: </span><br><span class="line">- Hexo</span><br><span class="line">- github</span><br><span class="line">- mac</span><br><span class="line">categories: [个人博客搭建, Hexo]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>每一项对应的含义：  </p>
<table>
<thead>
<tr>
<th>type</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>文章标题</td>
<td></td>
</tr>
<tr>
<td>tags</td>
<td>文章标签</td>
<td>可用无序列表定义多个标签</td>
</tr>
<tr>
<td>date</td>
<td>文章创建时间</td>
<td>格式：2018-12-12 12:12:12</td>
</tr>
<tr>
<td>categories</td>
<td>文章分类</td>
<td>文章只属于一个分类，可定义子分类，使用[父分类,子分类]</td>
</tr>
</tbody></table>
<p>注意：每个选项冒号后面都必须空格，不然没法识别。</p>
<h4 id="7-2-2-文章摘要"><a href="#7-2-2-文章摘要" class="headerlink" title="7.2.2 文章摘要"></a>7.2.2 文章摘要</h4><p>在摘要结束的地方添加如下字符，即可生成摘要，建议手动设置，不推荐hexo的自动生成摘要的方式，因为无法保证摘要的完整性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>
<p>设置后的效果就是，首页文章只显示摘要，多了一个阅读全文的效果，如下：<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20210530161209.png" alt="摘要"></p>
<h4 id="7-2-3-文章内容"><a href="#7-2-3-文章内容" class="headerlink" title="7.2.3 文章内容"></a>7.2.3 文章内容</h4><p>个人使用markdown编辑器是MWeb和Typora，文章内容支持markdown编辑语法，markdown语法相关请参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/191d1e21f7ed">Markdown基本语法</a></li>
<li><a href="https://www.markdown.xyz/">Markdown 指南中文版</a></li>
</ul>
<h4 id="7-2-4-文章中的图片"><a href="#7-2-4-文章中的图片" class="headerlink" title="7.2.4 文章中的图片"></a>7.2.4 文章中的图片</h4><p>建议将图片上传至图床，图床的搭建请google搜索。<br>个人淌的坑有：</p>
<ul>
<li>gitee防盗链</li>
<li>七牛云必须有域名才可使用免费空间，大流量需收费</li>
<li>微博图床不可用</li>
<li>github墙内无法访问</li>
</ul>
<p>本人使用github+PicGo搭建，使用JSDelivr进行CDN加速，具体详细教程请参考：</p>
<ul>
<li><a href="https://learnku.com/articles/48574">如何使用 Github 作为自己的免费图床</a></li>
<li><a href="https://ji2xpro.github.io/73d224e9/">Hexo博客指南|第六篇:图床神器PicGo</a></li>
<li><a href="https://blog.csdn.net/qq_36759224/article/details/98058240">Github+jsDelivr+PicGo 打造稳定快速、高效免费图床</a></li>
</ul>
<h3 id="7-3-博客问题记录"><a href="#7-3-博客问题记录" class="headerlink" title="7.3 博客问题记录"></a>7.3 博客问题记录</h3><p>文章生成的目录无法跳转，点击报错，通过f12查看如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cannot read property &#x27;top&#x27; of undefined</span><br></pre></td></tr></table></figure>
<p>查了很久，大家遇到的问题都不太一样，本人通过这篇博客解决了我的问题，附上链接：<br><a href="https://www.geek-share.com/detail/2819196740.html">如何解决next5主题目录无法跳转的问题</a></p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><p>上述内容可能存在实效性，如果有问题，欢迎提出，本人及时更新相关内容。</p>
]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>github</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/24/Android-View-getVisibility/</url>
    <content><![CDATA[<h1 id="View-getVisiblity-出现NullPointerException的详细分析"><a href="#View-getVisiblity-出现NullPointerException的详细分析" class="headerlink" title="View.getVisiblity()出现NullPointerException的详细分析"></a>View.getVisiblity()出现NullPointerException的详细分析</h1><hr>
<p>title: Android Gradle（一）Gradle的Android插件入门<br>date: 2021-10-24 22:52:14<br>tags: </p>
<ul>
<li>Android</li>
<li>Crash</li>
<li>View</li>
</ul>
<p>categories: [Android,Crash]</p>
<hr>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在bugly上面收集到项目View.getVisiblity()的空指针异常，这个崩溃总量不大，但是一直存在，所以也没有特别花时间去关注，后面有一期需求，导致这个崩溃量上升，必须要解决了，本文将详细描述这个崩溃的排查过程和问题解决方法。</p>
<span id="more"></span>

<h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="bugly上报的具体堆栈信息"><a href="#bugly上报的具体堆栈信息" class="headerlink" title="bugly上报的具体堆栈信息"></a>bugly上报的具体堆栈信息</h3><p>bugly上具体的堆栈如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.NullPointerException</span><br><span class="line">Attempt to invoke virtual method <span class="string">&#x27;int android.view.View.getVisibility()&#x27;</span> on a <span class="keyword">null</span> object reference</span><br><span class="line"></span><br><span class="line">android.widget.FrameLayout.layoutChildren(FrameLayout.java:<span class="number">284</span>)</span><br><span class="line">android.widget.FrameLayout.onLayout(FrameLayout.java:<span class="number">270</span>)</span><br><span class="line">android.view.View.layout(View.java:<span class="number">22958</span>)</span><br><span class="line">android.view.ViewGroup.layout(ViewGroup.java:<span class="number">6433</span>)</span><br><span class="line">android.widget.LinearLayout.setChildFrame(LinearLayout.java:<span class="number">1829</span>)</span><br><span class="line">android.widget.LinearLayout.layoutVertical(LinearLayout.java:<span class="number">1673</span>)</span><br><span class="line">android.widget.LinearLayout.onLayout(LinearLayout.java:<span class="number">1582</span>)</span><br><span class="line">android.view.View.layout(View.java:<span class="number">22958</span>)</span><br><span class="line">android.view.ViewGroup.layout(ViewGroup.java:<span class="number">6433</span>)</span><br><span class="line">android.widget.FrameLayout.layoutChildren(FrameLayout.java:<span class="number">332</span>)</span><br><span class="line">android.widget.FrameLayout.onLayout(FrameLayout.java:<span class="number">270</span>)</span><br><span class="line">android.view.View.layout(View.java:<span class="number">22958</span>)</span><br><span class="line">android.view.ViewGroup.layout(ViewGroup.java:<span class="number">6433</span>)</span><br><span class="line">android.widget.LinearLayout.setChildFrame(LinearLayout.java:<span class="number">1829</span>)</span><br><span class="line">android.widget.LinearLayout.layoutVertical(LinearLayout.java:<span class="number">1673</span>)</span><br><span class="line">android.widget.LinearLayout.onLayout(LinearLayout.java:<span class="number">1582</span>)</span><br><span class="line">android.view.View.layout(View.java:<span class="number">22958</span>)</span><br><span class="line">android.view.ViewGroup.layout(ViewGroup.java:<span class="number">6433</span>)</span><br><span class="line">android.widget.FrameLayout.layoutChildren(FrameLayout.java:<span class="number">332</span>)</span><br><span class="line">android.widget.FrameLayout.onLayout(FrameLayout.java:<span class="number">270</span>)</span><br><span class="line">com.android.internal.policy.DecorView.onLayout(DecorView.java:<span class="number">789</span>)</span><br><span class="line">android.view.View.layout(View.java:<span class="number">22958</span>)</span><br><span class="line">android.view.ViewGroup.layout(ViewGroup.java:<span class="number">6433</span>)</span><br><span class="line">android.view.ViewRootImpl.performLayout(ViewRootImpl.java:<span class="number">3547</span>)</span><br><span class="line">android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:<span class="number">3015</span>)</span><br><span class="line">android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:<span class="number">2029</span>)</span><br><span class="line">android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:<span class="number">8354</span>)</span><br><span class="line">android.view.Choreographer$CallbackRecord.run(Choreographer.java:<span class="number">972</span>)</span><br><span class="line">android.view.Choreographer.doCallbacks(Choreographer.java:<span class="number">796</span>)</span><br><span class="line">android.view.Choreographer.doFrame(Choreographer.java:<span class="number">731</span>)</span><br><span class="line">android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:<span class="number">957</span>)</span><br><span class="line">android.os.Handler.handleCallback(Handler.java:<span class="number">938</span>)</span><br><span class="line">android.os.Handler.dispatchMessage(Handler.java:<span class="number">99</span>)</span><br><span class="line">android.os.Looper.loop(Looper.java:<span class="number">223</span>)</span><br><span class="line">android.app.ActivityThread.main(ActivityThread.java:<span class="number">7986</span>)</span><br><span class="line">java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">603</span>)</span><br><span class="line">com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">947</span>)</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们都知道view的绘制从ViewRootImpl的performTraversals方法开始，依次执行Measure、Layout、Draw：</p>
<ul>
<li>performMeasure -&gt; measure-&gt;onMeasure：测量</li>
<li>performLayout-&gt;layout-&gt;onLayout：布局</li>
<li>performDraw-&gt;draw-&gt;onDraw：真正的绘制</li>
</ul>
<p>从异常的堆栈信息来看，当前正在执行View绘制中layout过程，也就是根据子视图的大小以及布局参数将View树放到合适的位置上。具体的过程在这里不做详细描述了，我们直接看到最后崩溃的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android.widget.FrameLayout.layoutChildren(FrameLayout.java:<span class="number">284</span>)</span><br></pre></td></tr></table></figure>
<p>查看FrameLayout.java源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            ...</span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码，可以知道出现空指针的原因是因为getChildAt(index)拿到了一个空的View。</p>
<p>可是为什么会拿到空呢，我们可以先看看getChildCount是如何计算的:<br>ViewGroup.java部部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Child views of this ViewGroup</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)</span></span><br><span class="line"><span class="keyword">private</span> View[] mChildren;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number of valid children in the mChildren array, the rest should be null or not</span></span><br><span class="line"><span class="comment">// considered as children</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mChildrenCount;</span><br></pre></td></tr></table></figure>
<p>从源码上来看，ViewGroup内部通过数组mChildren和mChildrenCount来维护子view的列表。在addView和removeView的时候，数组和mChildrenCount会发生改变，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index, LayoutParams params)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    addViewInner(child, index, params, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addViewInner</span><span class="params">(View child, <span class="keyword">int</span> index, LayoutParams params,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">boolean</span> preventRequestLayout)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    addInArray(child, index);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addInArray</span><span class="params">(View child, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    children[index] = child;</span><br><span class="line">    mChildrenCount++;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (removeViewInternal(view)) &#123;</span><br><span class="line">        requestLayout();</span><br><span class="line">        invalidate(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">removeViewInternal</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = indexOfChild(view);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        removeViewInternal(index, view);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeViewInternal</span><span class="params">(<span class="keyword">int</span> index, View view)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    removeFromArray(index);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method also sets the child&#x27;s mParent to null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeFromArray</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    System.arraycopy(children, index + <span class="number">1</span>, children, index, count - index - <span class="number">1</span>);</span><br><span class="line">    children[--mChildrenCount] = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个过程还是很清晰的，有兴趣的可以去跟踪一下源码。</p>
<p>我们再回到最初的问题上：view = getChildAt(index)为什么为空呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount(); <span class="comment">// 1.获取当前子view的数量，本质是mChildrenCount</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i); <span class="comment">// 2.get当前index为i的view，本质是mChildren[index]</span></span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123; <span class="comment">//3.当前index为i的view的可见性</span></span><br><span class="line">            ...</span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height); <span class="comment">// 4.执行当前index为i的子view的layout过程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种可能存在的情况：执行到1处，假设mChildrenCount为10，在接下来遍历过程中，执行FrameLayout所有子view的layout方法。假设在执行index为2的view的layout方法过程中，remove了FrameLayout中index为7的view，当遍历到index7时，这时候getChildAt(i)就为空了，导致执行3处时，出现空指针异常。</p>
<p>接下来将进行两个场景的分析，验证以上的猜想。</p>
<h3 id="场景一："><a href="#场景一：" class="headerlink" title="场景一："></a>场景一：</h3><p>AppBarLayout是我们常用来做吸顶功能的控件，有一个需求功能，在滑动的时候，将页面内某个view移除，在这个场景下，复现概率很大。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">layoutAppbar.addOnOffsetChangedListener(AppBarLayout.OnOffsetChangedListener &#123; _, offset -&gt;</span><br><span class="line">    val parent = activity.findViewById(android.R.id.content)</span><br><span class="line">    parent.removeView(guideView)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们通过AppBarLayout源码看下AppBarLayout.onOffsetChanged回调时机：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// onOffsetChanged有两个调用处，很明显是onLayoutChild</span><br><span class="line">void onOffsetChanged(int offset) &#123;</span><br><span class="line">    ...</span><br><span class="line">    for (int i = 0, z = listeners.size(); i &lt; z; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        listener.onOffsetChanged(this, offset);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean onLayoutChild(@NonNull CoordinatorLayout parent, @NonNull T abl, int layoutDirection) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // Make sure we dispatch the offset update</span><br><span class="line">    abl.onOffsetChanged(getTopAndBottomOffset());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看看AppBarLayout的onLayoutChild是谁调用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoordinatorLayout</span></span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = ViewCompat.getLayoutDirection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = mDependencySortedChildren.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mDependencySortedChildren.get(i);</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</span><br><span class="line">                <span class="comment">// If the child is GONE, skip...</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> Behavior behavior = lp.getBehavior();</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (behavior == <span class="keyword">null</span> || !behavior.onLayoutChild(<span class="keyword">this</span>, child, layoutDirection)) &#123;</span><br><span class="line">                onLayoutChild(child, layoutDirection);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在CoordinatorLayout的onLayout方法中被调用，<code>behavior.onLayoutChild(this, child, layoutDirection)</code>，而CoordinatorLayout的onLayout由顶层的FrameLayout调用，刚好符合前面的分析。</p>
<p>我们在梳理一下这种场景下的崩溃过程：</p>
<ul>
<li>前提：被移除的view记为A，且它是被添加到android.R.id.content里面的；</li>
<li>android.R.id.content执行onLayout，获取当前childCount，开始遍历，调用子View的layout方法；</li>
<li>CoordinatorLayout为android.R.id.content中一个子view，执行其layout方法，触发AppBarLayout的onLayoutChild方法，从而触发onOffsetChanged方法；</li>
<li>业务代码收到OnOffsetChangedListener回调，执行代码removeView操作，导致A被移除，导致childCount-1，view数组大小-1；</li>
<li>android.R.id.content继续执行遍历，由于childCount是提前获取的，而此时view数组的大小已经小于childCount，遍历到最后一个，出现空指针。</li>
</ul>
<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>从场景一可以联想到，RecyclerView滑动的时候是不是会有同样的问题呢？RecyclerView也是我们很常用的控件了，如果在滑动的过程中，也会导致同样的崩溃。<br>简单跟踪一下RecyclerView的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    dispatchLayout();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    dispatchLayoutStep3();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    dispatchOnScrolled(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchOnScrolled</span><span class="params">(<span class="keyword">int</span> hresult, <span class="keyword">int</span> vresult)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mScrollListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mScrollListeners.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            mScrollListeners.get(i).onScrolled(<span class="keyword">this</span>, hresult, vresult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用链路是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RecyclerView.layout()-&gt;RecyclerView.onLayout()-&gt;dispatchLayout-&gt;dispatchLayoutStep3-&gt;dispatchOnScrolled</span><br></pre></td></tr></table></figure>
<p>如果我们在onScrolled中做removeView的操作，同样会导致空指针。</p>
<h3 id="demo验证"><a href="#demo验证" class="headerlink" title="demo验证"></a>demo验证</h3><p>在页面添加一个RecyclerView和手动add若干view，在recyclerView.OnScrollListener中removeView，我们放大以上场景，发现是必崩溃的，堆栈也跟bugly一致。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> adapter = CommonAdapter()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindView(R.id.recyclerView)</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> recyclerView: RecyclerView</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        ButterKnife.bind(<span class="keyword">this</span>)</span><br><span class="line">        addCustomViews()</span><br><span class="line">        initRecyclerView()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> scrollListener = <span class="keyword">object</span> : RecyclerView.OnScrollListener() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onScrolled</span><span class="params">(recyclerView: <span class="type">RecyclerView</span>, dx: <span class="type">Int</span>, dy: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onScrolled(recyclerView, dx, dy)</span><br><span class="line">            removeAllViews()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initRecyclerView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        recyclerView.layoutManager = LinearLayoutManager(<span class="keyword">this</span>, LinearLayoutManager.VERTICAL, <span class="literal">false</span>)</span><br><span class="line">        recyclerView.adapter = adapter</span><br><span class="line">        recyclerView.addOnScrollListener(scrollListener)</span><br><span class="line">        adapter.setData(mutableListOf(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> customViewList = mutableListOf&lt;View&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">addCustomViews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> parent = findViewById&lt;ViewGroup&gt;(android.R.id.content)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> view = TextView(<span class="keyword">this</span>)</span><br><span class="line">            customViewList.add(view)</span><br><span class="line">            parent.addView(view)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeAllViews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> parent = findViewById&lt;ViewGroup&gt;(android.R.id.content)</span><br><span class="line">        customViewList.forEach &#123;</span><br><span class="line">            parent.removeView(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后的崩溃堆栈：<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20211024214011.png"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>简单总结一下这个崩溃的场景，如下图，是一个页面的View层级示意图。</p>
<ul>
<li>当顶层ViewGroup1进行onLayout时，获取childCount为N，遍历执行子view的layou方法</li>
<li>触发viewGroup2的onLayout，从而触发view5的onLayout方法，在其layout过程中，removeView了ViewGroup1下的view3，导致N的值变为N-1</li>
<li>当ViewGroup1继续遍历，获取index为N-1的view时，这时候获取的view就是空的，从而导致执行child.getVisibility()出现异常<br><img src="https://cdn.jsdelivr.net/gh/yishunjiande/PictureContainer@main/img/20211024223646.png"></li>
</ul>
<h2 id="问题解决方法"><a href="#问题解决方法" class="headerlink" title="问题解决方法"></a>问题解决方法</h2>]]></content>
  </entry>
</search>
